<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd User</title>
<link rel="stylesheet" href="jda.css" type="text/css">

<body>
<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;User</span>
<span class=ms>J-integrated<br>columnar<br>analytics</span>
</div>
<div contenteditable="false">
<codenopre)<p>User ops are executed by jd (<code>jd'...'</code>) and can run in the user Jd task or on a server Jd task.</p>
<!-- opindex a --><a href="#close">close</a>
<a href="#createcol">createcol</a>
<a href="#createdb">createdb</a>
<a href="#createdynamic">createdynamic</a>
<a href="#createhash">createhash</a>
<a href="#createtable">createtable</a>
<a href="#createunique">createunique</a>
<a href="#csvcdefs">csvcdefs</a>
<a href="#csvdump">csvdump</a>
<a href="#csvrd">csvrd</a>
<a href="#csvreport">csvreport</a>
<a href="#csvrestore">csvrestore</a>
<a href="#csvwr">csvwr</a>
<a href="#datatune">datatune</a>
<a href="#delete">delete</a>
<a href="#dropcol">dropcol</a>
<a href="#dropdb">dropdb</a>
<a href="#dropdynamic">dropdynamic</a>
<a href="#dropfilesize">dropfilesize</a>
<a href="#droptable">droptable</a>
<a href="#gen">gen</a>
<a href="#get">get</a>
<a href="#info">info</a>
<a href="#insert">insert</a>
<a href="#list">list</a>
<a href="#loadcustom">loadcustom</a>
<a href="#option">option</a>
<a href="#read">read</a>
<a href="#reads">reads</a>
<a href="#readtc">readtc</a>
<a href="#reference">reference</a>
<a href="#set">set</a>
<a href="#tableappend">tableappend</a>
<a href="#tablecopy">tablecopy</a>
<a href="#tableinsert">tableinsert</a>
<a href="#tablemove">tablemove</a>
<a href="#update">update</a>
<a href="#validate">validate</a>
<!-- opindex z -->
</codenopre><code><hr><a href="#use">use</a>      - <a href="#delete">delete</a> <a href="#info">info</a> <a href="#insert">insert</a> <a href="#list">list</a> <a href="#read">read</a> <a href="#reads">reads</a> <a href="#readtc">readtc</a> <a href="#update">update</a><br>
<a href="#manage">manage</a>   - <a href="#createcol">createcol</a> <a href="#createdb">createdb</a> <a href="#createtable">createtable</a><br>           <a href="#dropcol">dropcol</a> <a href="#dropdb">dropdb</a> <a href="#dropfilesize">dropfilesize</a> <a href="#droptable">droptable</a><br>
<a href="#dynamic">dynamic</a>  - <a href="#createdynamic">createdynamic</a> <a href="#createhash">createhash</a> <a href="#createunique">createunique</a><br>           <a href="#dropdynamic">dropdynamic</a> <a href="#reference">reference</a></a><br>
<a href="#csv">csv...</a>   - <a href="#csvcdefs">csvcdefs</a> <a href="#csvdump">csvdump</a> <a href="#csvrd">csvrd</a> <a href="#csvreport">csvreport</a> <a href="#csvrestore">csvrestore</a> <a href="#csvwr">csvwr</a> <br>
<a href="#table">table...</a> - <a href="#tableappend">tableappend</a> <a href="#tablecopy">tablecopy</a> <a href="#tableinsert">tableinsert</a> <a href="#tablemove">tablemove</a><br>
<a href="#misc">misc</a>     - <a href="#close">close</a> <a href="#gen">gen</a> <a href="#get">get</a> <a href="#loadcustom">loadcustom</a> <a href="#option">option</a> <a href="#set">set</a> <a href="#validate">validate</a>
<hr><a href="#args">args</a> <a href="#demos">demos</a> <a href="#types">types</a>
<hr><a name="use"><h2>use</h2></a>
<a href="#read">read</a>    [<a href="#select">select</a>]  <a href="#from">from</a>   table   [<a href="#where">where</a>]
<a href="#read">reads</a>   [<a href="#select">select</a>]  <a href="#from">from</a>   table   [<a href="#where">where</a>]
<a href="#insert">insert</a>  table     col    data     ...
<a href="#update">update</a>  table     <a href="#where">where</a>  col      data  ...
<a href="#delete">delete</a>  table     <a href="#where">where</a>
<a href="#info">info</a>    type

<hr><a name="manage"><h2>manage</h2></a>
<a href="#close">close</a>
<a href="#createdb">createdb</a>    
<a href="#createcol">createcol</a>   table  col   type  [ts] [data]
<a href="#createtable">createtable</a> table  [coldefs]
<a href="#dropdb">dropdb</a>
<a href="#dropfilesize">dropfilesize</a>
<a href="#droptable">droptable</a>   table
<a href="#dropcol">dropcol</a>     table  col

<hr><a name="dynamic"><h2>dynamic</h2></a>
dynamic cols are system cols that are built from data cols
dynamic cols are updated when the underlying data cols change

<a href="#createdynamic">createdynamic</a>
<a href="#createhash">createhash</a>   tab cols...
<a href="#createunique">createunique</a> tab cols...
<a href="#dropdynamic">dropdynamic</a>
<a href="#reference">reference</a>    tab1      cols...  tab2  cols...

<hr><a name="csv"><h2>csv...</h2></a>
<a href="#csvwr">csvwr</a>      [options] csvfile table [0 or more col names] [<a href="#where">where</a>]
<a href="#csvrd">csvrd</a>      [options] csvfile table
<a href="#csvdump">csvdump</a>
<a href="#csvrestore">csvrestore</a>
<a href="#csvreport">csvreport</a>  [options] [0 or more table names]
<a href="#csvcdefs">csvcdefs</a>   [options] csvfile - create x.cdefs from x.csv

CSVFOLDER__ - implicit arg - path for csv and related files
csv files can be on a different drvie than Jd tables
csv intermediate files are on the same drive as Jd tables
f.csv metadata in f.cdefs
 tutorial csv

<hr><a name="table"><h2>table...</h2></a>
<a href="#tableappend">tableappend</a> snktable  srctable srcdan
<a href="#tableinsert">tableinsert</a> snktable  srctable srcdan
<a href="#tablecopy">tablecopy</a>   snktable  srctable srcdan
<a href="#tablemove">tablemove</a>   snktable  srctable srcdan

tutorial table_table_table

<hr><a name="misc"><h2>misc</h2></a>
<a href="#gen">gen</a>     type      ...                  - create test table(s)
<a href="#get">get</a>     table     col                  - dat (varbyte val)
<a href="#loadcustom">loadcustom</a>
<a href="#option">option</a>  space     0 or 1               - 1 to report info last space
<a href="#set">set</a>     table     col      dat  [; varbyte val]

<hr><a name="args"><h2>args</h2></a>
jd args parse to a list of boxes
string treated as list of blank delimited boxes
first box treated as a string of blank delimited boxes

jd'reference a b c d' === jd'reference';'a';'b';'c';'d'
jd'insert f a';23     === jd'insert';'f';'a';23

<hr><a name="demos"><h2>demos</h2></a>
sandp, northwind, sed, vr
jdrt_jd_''

<hr><a name="types"><h2>types</h2></a>
standard types: boolean, int, float, byte
all standard types can have trailing shape
jd'createtable f a int 2,b byte 4' NB. n,2 int and n,4 byte

edate (epochdt) types:
iso 8601 format - stored as int - converted on read and write
epochdt int is nanoseconds before/after 2000-01-01

edate      - 2014-01-02
edatetime  - 2014-01-02T03:04:05
edatetimem - 2014-01-02T03:04:05,123
edatetimen - 2014-01-02T03:04:05,123456789

tutorial epochdt

date types:
date     - int with digits yyyymmdd
datetime - int with digits yyyymmddhmmss
csv loader supports yyyy/mm/dd vs dd/mm/yyyy

varbyte:
less important in Jd than in most other systems
byte 200 that held the data is probably better
  
<hr><a name="close"><h2>close</h2></a>
umnaps all files and closes all locales
does not affect admin or locks

jd ops map files and create locales as required

mapping and creating locales takes time so close only when necessary

<hr><a name="createcol"><h2>createcol</h2></a>
jd'createcol table col type [trailing-shape]'

creates new col with type and trailing-shape

createcol table col type trailing-shape data
creates new col with data values
trailing-shape must be provided and _ indicates empty

NB. example createcol
jdadminx'example'[olddan=:jdaccess''
jd'createtable f'
jd'createcol f a int'
jd'insert f a';12 13 14
jd'createcol f b int'
jd'createcol f c int 2'
jd'createcol f d int _';88 89 90
jd'createcol f e int 2';100+i.3 2
jd'reads from f'
jdaccess olddan

<hr><a name="createdb"><h2>createdb</h2></a>
valid only after a dropdb
creates filefolder and initial files
gets lock

<hr><a name="createdynamic"><h2>createdynamic</h2></a>
createdynamic

does dropdynamic to drop existing dynamic cols
runs db dynamic verb (custom.ijs) to create dynamic cols

<hr><a name="createhash"><h2>createhash</h2></a>
jd'createhash t1 cols...'

creates hash col based on 1 or more data cols
hash on col a has name of jdhash_a
hash on cols a and b has name of jdhash_a_b
hash col has 2 mapped nouns hash and link

#hash is larger (typically 1.5 times) #col
#link is same as #col and links rows with the same values

<hr><a name="createtable"><h2>createtable</h2></a>
createtable table [alloc] [coldefs]

createtable with 0 or more cols
each col defined by: col type [trailing-shape]

string arg coldefs separated by , or LF
boxed arg coldefs in separate boxes

alloc is 3 values - elided default is 2000 1.5 0
ROWMIN  minimum rows
ROMMULT multiplier
ROWXTRA extra rows
when insert requires mapped col file resize, new size is:
   ROWMIN>.>.ROWMULT*ROWXTRA+current_rows+new_rows

NB. example createtable
jdadminx'example'[olddan=:jdaccess''
jd'createtable f'
jd'createtable g a int , b int 2'
jd'createtable h';'a int';'b int 2'
t=: 0 : 0
a int
b int 2
)
jd'createtable i ',t
jd'info schema'
jdaccess olddan

<hr><a name="createunique"><h2>createunique</h2></a>
createunique t1 cols...

tutorial unique

<hr><a name="csvcdefs"><h2>csvcdefs</h2></a>
csvcdefs   [options] csvfile
 /replace - replace exisiting cdefs file
 /c       - .cnames file used for column names
 /h n     - n headers
 /u m     - m default col names
 /v w     - byte col wider than w treated as varbyte - default 200
 col types determined by examining probed rows
 
probed rows are the first 5000 rows 

/u m creates default .cname file with m cols
 cols at end with no data in probed rows are removed

csv metadata - .cdefs file format

eol delimited column definitions

col name type [width]
 col is 1 origin column number in csv file
 name is column name (used in file/folder names)
 type
  boolean, int, float, byte, varbyte
  date      - yyyy/mm/dd
  datex     - dd/mm/yyyy
  datetime  - yyyy/mm/dd hh:mm:ss 
  datetimex - dd/mm/yyyy hh:mm:ss
   
width
 must not be 0
 byte column width - elided is list 
 varbyte average (file allocation - elide for default)
 numeric column width
  - elided is list - value ignored and set as 1+#CSTITCH

options colsep rowsep quoted escaped headers
 colsep  - 1 char or BLANK or TAB or AUTO
 rowsep  - 1 or 2 chars or CR or LF or CRLF or AUTO
 quoted  - 1 char (usually ") or NO
 escaped - 1 char (usually \) or NO - \0 \b \t \n \r \" \' \\
 headers - 0 up to 10 header rows to skip

<hr><a name="csvdump"><h2>csvdump</h2></a>
csvdump
 wr all tables
 db files (e.g. admin.ijs) are dumped

<hr><a name="csvrd"><h2>csvrd</h2></a>
csvrd [options] csvfile table
 /rows n - read n rows - default 10 - 0 for all

<hr><a name="csvreport"><h2>csvreport</h2></a>
csvreport [options] [0 or more tables]
 /f does full report rather than summary
 report results of last csvrd for tables

<hr><a name="csvrestore"><h2>csvrestore</h2></a>
csvrestore
 rd all tables
 db files (e.g. admin.ijs) are restored

<hr><a name="csvwr"><h2>csvwr</h2></a>
csvwr [options] csvfile table [0 or more col names] [where clause]
 /h1 - header with col names
 /w  - final arg is where clause  
 all cols written if none are named
 where clause after * to avoid blank/quote problems

<hr><a name="datatune"><h2>datatune</h2></a>
datatune table ...

applies table datatune verb - shows what would be inserted

<hr><a name="delete"><h2>delete</h2></a>
delete table <a href="#where">where</a>

NB. example delete
jdadminx'example'[olddan=:jdaccess''
jd'createtable f a int,b byte 4'
jd'insert f';'a';24 25 26;'b';3 4$'aaaabbbbcccc'
jd'delete f a=24'
jd'delete f';'a=26'
jd'reads from f'
jdaccess olddan

<hr><a name="dropcol"><h2>dropcol</h2></a>
dropcol table col
drops the col
error if col does not exist
fails if there are related dynamic cols (ref,...)

<hr><a name="dropdb"><h2>dropdb</h2></a>
drops each col of each table
releases lock
deletes filefolder

<hr><a name="dropdynamic"><h2>dropdynamic</h2></a>
dropdynamic

drop all dynamic cols
some ops are simpler and run faster without dynamics to update

<hr><a name="dropfilesize"><h2>dropfilesize</h2></a>
jd'dropfilesize'

files tend to be kept larger than required
data in the file can grow without having to resize/remap

dropfilesize frees up unused file space - use if a db is static

dropfilesize returns filenames, old size, new size

<hr><a name="droptable"><h2>droptable</h2></a>
droptable table
ok if table does not exist
drops each col and the table
fails if there are related dynamic cols (ref,...)

<hr><a name="gen"><h2>gen</h2></a>
gen test table rows
gen ref2 table1 rows1 cols table2 rows2
gen one  table rows cols
gen two  table1 rows1 table2 [rows2]

generate test table(s)

test - table with all col types
ref2 - reference table1 aref table2 bref - extra cols
one  - table with extras cols
two  - default rows2 is <.rows1%10 - suitable for many to one join

NB. example gen
jdadminx'example'[olddan=:jdaccess''
jd'gen test f 3'        NB. f with 3 rows
jd'reads from f'
jd'gen ref2 g 5 2 h 3' NB. g 5 rows and 2 extra cols, h 3 rows
jd'reads from g,g.h'
jd'gen one i 3 2'
jd'reads from h'
jd'gen two j 6 k 3'
jd'reads from j'
jd'reads from k'
jdaccess olddan

<hr><a name="get"><h2>get</h2></a>
jd'get table col'

return raw col data - includes deleted data
varbyte - indexes;values
can be used with set to efficiently adjust col data
 
<hr><a name="info"><h2>info</h2></a>
jd'info ...' NB. info about current DB
 agg                        - select aggregators
 last                       - cmd time space
 map       [table [column]]
 reference [table]
 schema    [table [column]]
 state     [table [column]] - jdstate
 summary   [table]
 table
 varbyte   [table [column]]
 
 NB. example info
 jdadminx'example'[olddan=:jdaccess''
 jd'gen ref2 a 3 0 b 2'
 jd'info schema'
 jd'info schema a'
 jd'info schema a akey'
 jd'info reference'
 jdaccess olddan
  
<hr><a name="insert"><h2>insert</h2></a>
jd'insert table col data ...'

col data pairs
count of data items must be the same

NB. example insert
jdadminx'example'[olddan=:jdaccess''
jd'createtable f a int,b byte,b4 byte 4'
jd'insert';'f';'a';23;'b';'a';'b4';1 4$'abcd'
jd'reads from f'
jd'insert';'f';'a';24 25;'b';'bc';'b4';2 4$'aaaabbbb'
jd'reads from f'
jdaccess olddan

<hr><a name="list"><h2>list</h2></a>
jd'list ...'
 version     - Jd version 
 open        - open databases

<hr><a name="loadcustom"><h2>loadcustom</h2></a>
jd'loadcustom'

load <a href="#custom.ijs">custom.ijs</a> from db folder db locale

<hr><a name="from"><h2>from</h2></a>
from clause - jd'reads ... from ...'

tutorial from

from Table (, Table)*
Table:     Root | Child
Root:      [alias:] table
Child:     [alias:] [JoinWord] Parent(Reference)(Reference)*
Parent:    alias | table
Reference: table | reference column
JoinWord:  default | inner | left | right | outer
Join:        .     |   -   |  &lt;   |   &gt;   |   =

The default join is also called left1.

Only one of the Tables can be the Root.
The name of a table is either its alias or the last element of its
description (i.e. the table for the Root, and the last Reference for
Children). A table can only have one name: if an alias is given, the
other name will not be used.
Each Parent must be included as the name of some Table in the list.
No order is enforced on the Tables, in particular, a Child does
not have to follow its Parent.

example:
from A.B, A, C:B&lt;jdreference_a_C_a, inner C.D, B&gt;E-F

The join used to join a Reference to the table before it is
either the one corresponding to the Join symbol used, or,
if Join is . and JoinWord is given, that given by JoinWord.

By default joins are done in an optimal (not guaranteed)
order based on a sampling that picks representative rows
and tests how restrictive the queries are. The algorithm
should be fairly robust.

exact keyword indicates to use the order as given.
   jd'read from exact f,f-g,g-h where h.a&lt;100'

See 'help join' for a description of the types of joins.

<hr><a name="join"><h2>join</h2></a>
joins: inner -  outer=   left &gt;  right &lt;  left1 ,

outer join A,A=B
 all possible rows
 A rows duplicated for each match in B
 B rows duplicated for each match in A
 A or B FILLS provided where no match

inner join A,A-B:
 same as outer except rows with FILLS are excluded
 
left join A,A&gt;B
 same as outer except B rows that did not match are excluded
 
right join A,A&lt;B
 same as outer except A rows that did not match are excluded

left1 join A,A.B
 each A row with 1 matching B row or FILLS
 if multiple matching B rows, 1 random one of them is used
 not a normal join, but is fast
 same as inner join if 1 and only 1 B row matches 

<hr><a name="option"><h2>option</h2></a>
jd'option space ...'

option space 1 to record last command space
option space 0 to not record (reported as _1)

jd'info last' report last cmd, time, space

<hr><a name="read"><h2>read</h2></a>
jd'read [/e] [select] from [where]' NB. labeled rows

same as reads with /lr option

<hr><a name="reads"><h2>reads</h2></a>
jd'reads [/lr] [/e] [<a href="#select">select</a>]  <a href="#from">from</a>  [<a href="#where">where</a>]' NB. labeled cols

/lr - labeled rows instead of labeled cols 
/e  - edate... cols as epochdt rather than iso 8601

<a href="#join">join</a> adds additional tables to the from root table

returns select col(s) from table(s) with rows that satisfy where
alias:col
alias:table
aggregation [by key1[,key2]]

NB. example reads
jdadminx'example'[olddan=:jdaccess''
jd'gen ref2 a 3 1 b 2'
jd'reads from a'
jd'reads from b'
jd'reads akey,adata from a'
jd'reads from a,a.b'
jd'reads from a where akey&lt;3'
jd'reads from a,a.b where akey&lt;3 and b.bref=0'
jd'reads asdf:b.bb12 from a,a.b where akey&lt;3 and b.bref=0'
jd'reads sum adata from a where akey&gt;0'
jd'reads sum adata by aref from a'
jdaccess olddan

<hr><a name="readtc"><h2>readtc</h2></a>
jd'readtc [/lr] [/e] :::...::: [<a href="#select">select</a>]  <a href="#from">from</a>  [<a href="#where">where</a>]'

same as reads except J sentence bracketed by :::
is executed first to create temp cols

tutorial tempcol

<hr><a name="reference"><h2>reference</h2></a>
reference t1 cols... t2 cols...

allows outer/inner/left/right/left1 <a href="#join">join</a>
does createhash if required
uses previous createunique
inserts/deletes/updates update dynamic cols as required

<hr><a name="select""><h2>select</h2></a>
select clause - jd'reads SELECT from ...'

 cola
 alias:cola
 cola,colb
 *
 tabf.cola,tabg.colc
 *.*
 
 sum cola
 sum cola,avg colb

 sum cola by key1
 sum cola by key1,key2

default aggs: avg count countunique first last max min sum
   jd'info agg' NB. database agg functions (may include custom functions)

alias:col labels the result column.

<h2>select details</h2>
Select: Column(, Column)*
      | AggCol(, AggCol)*
      | AggCol(, AggCol)* by Column(, Column)*
Column: [alias:] [Tab.]Col
AggCol: [alias:] agg [Tab.]Col
Tab: table  | "*"
Col: column | "*"

table is the name of a table in the from clause
(alias, name, or the column used to reference it).
The root table is used if there is no TAB.

column is the name of a column in the corresponding table.

alias is a name.

agg is an aggregation function.

Select determines which columns are in the result.

If not an aggregation then * can be used for Tab and Col.
If Tab is *, then that column will be shown for all tables.
If Col is *, then all columns from the table will be used.
Tab expanded first so  *.* gives all columns from all tables.
If no Columns are given, then *.* is used, or * if only one table.

The name in the result for a col is its alias, or how it was identified.

The by keyword groups rows by the key columns that follow it.
Each aggregator is called on the rows of its column in each group.

default aggs: avg count countunique first last max min sum
   jd'info agg' NB. database agg fns (may include custom functions)
   
Result column label does not include agg, so an alias is desireable.

<hr><a name="set"><h2>set</h2></a>
jd'set table col';data

set raw col data - includes deleted data
varbyte - indexes;values
can be used with get to efficiently adjust col data

<hr><a name="tableappend"><h2>tableappend</h2></a>
jd'tableappend snktable srctable srcdan' NB. implicit jdaccess'srcdan'

implemented as a loop over corresponding cols
reads src col file and appends to snk col file
insists there are no dynamic columns as they would not be updated
copies deleted rows and their deleted status

for bulk updates (lots of new data from csv files for multiple tables)
dropdynamic/tableappends/createdynamic can be faster than tableinsert

NB. example tableappend
jdadminx'example'[olddan=:jdaccess''
jd 'createtable f a int'
jd 'insert f';'a';i.2
jdadminx'example2'
jd 'createtable g a int'
jd 'insert g';'a';100+i.2
jdaccess'example'
jd'tableappend f g example2'
jd'reads from f'
jdaccess olddan

<hr><a name="tablecopy"><h2>tablecopy</h2></a>
jd'tablecopy snktable srctable srcdan' NB. implicit jdaccess'srcdan'

copies a table from srcdan to the current db
uses host file copy and runs as fast as hardware allows

NB. example tablecopy
jdadminx'example'[olddan=:jdaccess''
jdadminx'example2'
jd 'createtable f a int'
jd 'insert f';'a';i.2
jdaccess'example'
jd'tablecopy new f example2'
jd'reads from new'
jdaccess olddan

<hr><a name="tableinsert"><h2>tableinsert</h2></a>
jd'tableinsert snktable srctable srcdan' NB. implicit jdaccess'srcdan'

implemented as a loop of block read/insert
read ignores deleted rows in the src table
insert updates dynamic columns in the snk database

for large, complex updates it might be faster to use tableappend

NB. example tableinsert
jdadminx'example'[olddan=:jdaccess''
jd 'createtable f a int'
jd 'insert f';'a';i.2
jdadminx'example2'
jd 'createtable g a int'
jd 'insert g';'a';100+i.2
jdaccess'example'
jd'tableinsert f g example2'
jd'reads from f'
jdaccess olddan

<hr><a name="tablemove"><h2>tablemove</h2></a>
jd'tablemove snktable srctable srcdan' NB. implicit jdaccess'srcdan'

moves a table from srcdan to the current db
uses host file move and runs fast as it justs updates pointers

srcdan must be on the same file hardware for move to work

NB. example tablemove
jdadminx'example'[olddan=:jdaccess''
jdadminx'example2'
jd 'createtable f a int'
jd 'insert f';'a';i.2
jdaccess'example'
jd'tablemove new f example2'
jd'reads from new' NB. table f in dan example2 no longer exists
jdaccess olddan

<hr><a name="update"><h2>update</h2></a>
jd'update table <a href="#where">where</a> col data  ...'

col data pairs
count of data items and updated rows must be the same.

NB. example update
jdadminx'example'[olddan=:jdaccess''
jd 'createtable f a int,b int,c byte 4'
jd 'insert f';'a';24 25 26;'b';100 101 102;'c';3 4$'aaaabbbbcccc'
jd'reads from f'
jd 'update f';'a=24';'b';200
jd'reads from f'
jd 'update f';'a<26';'b';300 400;'c';2 4$'xxxxzzzz'
jd'reads from f'
jdaccess olddan

<hr><a name="validate"><h2>validate</h2></a>
jd'validate'

validates db and reports any problems
reports mismatch in table Tlen and column lengths
other tests will be added

needs option to fix Tlen problems by cutting back long cols

<hr><a name="where"><h2>where</h2></a>
where clause - jd'reads ... from ... where'

 a="abc"
 b&lt;23
 b in (23,24,25)
 b lt 23 && a eq "abc"
 a like "ab*" 
 f.a=23 && g.b="def"

relationals:
 &gt;= &lt;= &lt;&gt; =  &gt;   &lt;
 ge le ne eq gt lt
 in notin like unlike sample sample.

 non-symbol must be blank delimited

 byte data must be in "s and has C escapes (\" \t \n \0 \x09 ...)
 numeric data must not be in "s

 like/unlike regex applies to all types

 relationals have implied parens (which must not be present)
 
 a=c (c not a number and not in "s) is a relation between 2 cols

 t (no col/relational) selects rows from table t not created by join

logicals:
 !   &&  ||
 not and or

 must be blank delimited

 logicals evaluate as J (right to left)
  not a=23 && b=24 || b=25  ===  not((a=23)&&((b=24)||(b=25)))

 parens can change the order of evaluation

<h2>where details</h2>
where clause details

W:  ("!" | "not ")* W1
W1: W2 (" " ("and"|"or"|"&&"|"||") " " W)?
W2: "(" W ")"  |  Q
Q:  col relational dat  |  col relational col  |  tab

col is col name as in select and tab is table name

relationals:
 &gt;= &lt;= &lt;&gt; =  &gt;   &lt;
 ge le ne eq gt lt
 in notin like unlike sample sample.

Q expressions are in implicit parens, which must not be present.

dat represents a J noun; typically this must have the same type as the
items of the column, but its type depends on the operation being used.
If dat is a string or byte, it must be quoted; otherwise it
will be interpreted as numeric data, a column name, or an error.

Strings are in "s and C escapes (\", \n, etc.) can be used.

Logicals (! $$ || not and or) are grouped from right to left as in J,
with parentheses allowed for grouping.

The three types of simple query work as follows:
- For an operation on a col and data, the data is fixed so
  that it has the appropriate type and shape.
  For most operations, this is the same type and shape as an
  item in the column. For in and notin, its items will have
  that type and shape. For sample and sample., it
  will be converted to a single number. See the section on data
  conversion below. After conversion, the operation will be applied
  to select qualifying rows in the column.
- For an operation on two columns, the operation will be applied to
  pairs of rows from the two columns to select qualifying rows. The
  operations in, notin, like, unlike, sample, and sample. are not
  available on columns.
- The single table query selects rows that are not null.
  Null rows are created by some joins and do not correspond to a
  row in the table. They are indicated with fills.

The relationals are as follows:
- &gt;=, &lt;=, &gt;, &lt; are only available for numeric columns.
- in and notin test whether col value is an element of the list.
- like and unlike take a regex and test if the col data matches.
- sample and sample. require a data argument that is a single number.
  They select that many elements from the column to satisfy the query.

Data can be converted either to string (or byte) or numbers.
Numbers must include only the characters -_. and digits.
Strings must be quoted to avoid confusion with keywords and col names.

Following escapes are allowed in quoted strings:
\"     double quote
\\     backslash
\a     alert (BEL)
\b     backspace
\e     escape
\f     form feed
\n     new line
\r     carriage return
\t     horizontal tab
\v     vertical tab
\xHH   byte with hexadecimal value HH

Following escapes may be supported but their use is discouraged:
\NNN   byte with octal value NNN (1 to 3 digits)
\xHH   byte with hexadecimal value HH (1 to 2 digits)
\uHHHH Unicode  (ISO/IEC  10646)  character with hex value HHHH (4 digits)
\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)

Data is adjusted to the shape of the column. A list of data can
be provided by separating items with spaces (this works with numbers or
strings). If the data is smaller than the column shape, it will be
filled with the fill element corresponding to the column type. If it is
larger, an error is signalled.

For in and notin, data is given in a comma-separated list,
optionally enclosed by parens.
</code></div></div></body></html>
