<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd Overview</title>

<link rel="stylesheet" href="jda.css" type="text/css">

</head>
<body>

<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;Overview</span>
<span class=ms>J-integrated<br>columnar<br>analytics</span>
</div>

<div contenteditable="false">

<h2>Jd</h2>
<p>Yet another database. Why might you want one? Read on.</p>

<p>Jd is a commercial database product from Jsoftware. It has similarities with all
relational database management systems (RDBMS). Although similar in terminology
and features to MySQL,Oracle,DB2,SQL Server, and others, it is closer
in spirit and design to Kx's kdb, Vectornova's Vstar, Jsoftware's free JDB, and
all old APL based financial systems that ran on IBM mainframes in 70s and 80s.</p>

<h2>J-integrated</h2>

<p>The key difference between Jd and most other database systems is that Jd comes
with a fully integrated and mature programming language.
Jd is implemented in J and lives openly and dynamically in the J execution and
development environment. Jd is a natural extension of J and the full power of J is available to the
Jd database application developer. The integration is not just available to you,
it is unabashedly pushed to you for exploitation.</p>

<p>J is a modern, array-oriented, high-performance, general-purpose programming language.
In J the natural unit of information is a list (of booleans or integers or floats or datetimes or fixed length character
strings or variable length character strings or etc). In J, the list of all the license numbers
is a noun (named data object). And that noun can be mapped (memory mapped files)
directly to a file in the file system by the host OS. So the Jd table column of license
numbers is a single file. J can map that file to single J noun and work directly on all
that data. Jd table column -> file -> J noun. It doesn't get simpler or more efficient than this.</p>

<p>Early adopters of Jd are assumed to have a J background and
documentation and tutorials depend on that background.</p>

<p>End users of an application built on Jd, or a web service based  on
Jd, or reports generated by Jd, need no knowledge of J. Jd developers,
maintainers, and administrators need some knowledge of J and an overview of how a J system is installed and managed.</p>

<p>Selling Jd to someone who has
data problems and no knowledge of J is a tough sell. Or, on the positive side:
if you know J and have data problems, boy do we have what you want!</p>

<h2>columnar</h2>
<p>Jd is a columnar (column oriented) RDBMS.</p>

<p>Most RDBMS systems are row oriented. Ages ago they fell into the trap of thinking
of tables as rows (records). You can see how this happened.
The end user wants the record that has a first name, last name, license, make,
model, color, and date. So a row was the unit of information and rows were stored
sequentially on disk. Row orientation works for small amounts of data.
But think about what happens when there are lots of rows and the user
wants all rows where the license starts with 123 and the color is blue or black.
In a naive system the application has to read every single byte of data from the disk.
There are lots of bytes and reading from disk is, by orders of magnitude,
the slowest part of the performance equation. To answer this simple question
all the data had to be read from disk. This is a performance disaster and
that is where decades of adding bandages and kludges started.</p>

<p>Jd is columnar so the data is 'fully inverted'. This means all of the license numbers are stored together and sequentially on disk. The same for all the other columns. Think about the earlier query for license and color. Jd gets the license numbers from disk (a tiny fraction of the database)  and generates a boolean mask of rows that match. It then gets the color column from disk (another small fraction of the data) and generates a boolean mask of matches and ANDS that with the other mask. It can now directly read just the rows from just the columns that are required in the result. Only a small fraction of the data is read. In J, columns used in queries are likely already in memory and the query runs at ram speed, not the sad and slow disk speed.</p>

<p>Both scenarios above are simplified, but the point is strong and valid. The end user thinks in records, but the work to get those records is best organized by columns.</p>

<p>Row oriented is slavishly tied to the design ideas of filing cabinets and manila folders.  Column oriented embraces computers.</p>

<h2>analytics</h2>
<p>Jd is particularly suited to analytics. It works well with large tables (100s of millions of rows),
multiple tables connected by complex joins, structured data, numerical data,
and complex queries and aggregations.

<p>Jd performance is affected primarily by ram. Lots of ram allows lots of rows.
Performance is relatively unaffected by the number of columns and many 100s of columns are fine.
It is the number of rows and not the byte size of the database that counts.
</p>

<p>Jd supports a reasonable rate of individual record updates/inserts, but is definitely oriented
towards fast, customized, bulk updates. That is, periodic (hourly/daily/monthly) bulk loads of lots
of new records, perhaps from csv files dumped from a transactional database system, that are customized
(ETL) are fast and easy.
</p>

<p>Jd can serve dozens of simultaneous users of a database in their browsers with high-security
and managed access out of the box. This works well for a team of analysts. To serve hundreds or
thousands of users requires additional work to put the Jd server behind an apache/nginx/etc front end.
</p>

<p>
Jd has a small footprint, is easy to install, and multiple installations are encouraged. An analyst can run
Jd on their own computer to work with local databases. A group of analysts can access Jd on a server
that provides shared access to the same databases. A Jd instance can serve a single database or multiple
databases. A machine can run one or more Jd instances. This allows easy distribution and scalability.
</p>

<p>Jd is strong in analytics, but weaker in other areas. Jd is probably not the right choice for
big data (terrabytes of unstructured textual data) or for a high-rate transactional system with
many 1000s of users.
</p>

<h2>similarity</h2>
<p>Jd has one or more databases. A database has one or more tables.
A table is rows (unnamed) and columns (named).  Data in a column is 
of the same type (integer, float, datetime, fixed length characters,
variable length characters, etc.). Tables can be joined in various ways with other
tables to function as if they were that large table. Rows and columns can be retrieved
by queries on the joined tables. Retrieved data from a query can be aggregated, grouped, and sorted.
Rows can be deleted, updated, and inserted.</p>

<p>The Jd api is SQL like. Similar enough that if you are a guru in another RDBMS
you'll pick up the Jd way of thinking without much trouble. And if you're new,
then Jd with its tutorials and examples will give you a leg up on getting at your data.</p>

<h2>install</h2>
<p>Before installing Jd you need to install J64 (801 or later) on your
Windows/Linux/Mac system. Windows XP is not supported.</p>

<p>Your J system should be kept up to date. Use JAL/Packgage Manager to keep current with
the base library and all addons.</p>

<p>The preferred J front end for Jd is JHS. Eventually
your Jd systems are likely deployed in servers (perhaps in a cloud)
and JHS makes secure remote management and development a natural
continuation of using Jd on your own local machine.</p>

<p>If not already familiar with the JHS front end, time spent getting
familiar is time well spent.</p>


<p>Installation:
<ol><li>install data/jd addon with JAL/Package Manager</li>
<li>start J session (any front end, but slight bias for JHS)<code>
   load'data/jd'
...
...
   jdtests_jd_'' NB. validate install</code></ol>

<p>Be sure to browse and bookmark the documentation url given in the welcome.</p>

For a new install and after any updates it is a good idea to run
jdtests as this validates the installaion and creates demo databases.</p>

<h2>run</h2>
<p>The Jd welcome message after<br>
<code>   load'data/jd'</code> <br>
gives several suggestions on how to get started.</p>

<h2>tutorials</h2>
<p>
<code>   load'data/jd'
...
...
   jdrt_jd_'intro' NB. run intro tutorial
</code>

<p>As interest and need arises, work your way through the other tutorials.</p>

</code></p>

<h2>admin/backup</h2>

<p>Databases/tables/columns/metadata/etc are represented directly in the file
structure. A database is a folder. A table is a folder in the
database. A column is a folder in the table. The data is one or more
files in the column.</p>

</p>You can backup a database or a table with
standard host shell scripts, file copy commands, and tools such as
tar/gzip/zip. Jd will provide patterns for standard requirements and you can
easily roll your own customized version. If you understand backing up file folders,
then you pretty much understand backing up Jd databases.</p>

<p>You can also dump a database as csv files and restore a database from csv files.
Metadata such as column names and types, user administration data (who can do what),
and all other database specific information is automatically included.</p>

<p>Admin can control user access to a fine degree. Access requires a user/pswd and
can be restricted to certain ops.</p>

<h2>fast CSV</h2>
<p>Jd has a fast CSV loader. The process is managed in J, but the
high-performance core is written in C. The loader can handle all
reasonable CSV options, has good error reporting, and can get data
from external sources into Jd quickly. Data from new csv files (for
example, new hourly or daily data) can be quickly loaded and appended
to your existing production Jd tables.</p>

<p>Jd also has a fast CSV unloader with the core writtend in C.</p>

<h2>Jd and JDB</h2>
<p>JDB was an early effort, primarily by Chris Buke, that proved the
feasibility of building a database system in J. JDB is a free product
from Jsoftware and might suit your needs if you don't need the
high-performance and scalability to much larger databases that Jd
provides. If you've used and like JDB, you'll love Jd.</p>

<h2>open source</h2>
<p>Jd source is largely J code and that code is open and available to the J community.
There is a binary shared library (to get high performance at bottlenecks).
The Jd binary source is available to commercial users under the Premium Commercial Support Agreement.</p>

</div></body></html>
