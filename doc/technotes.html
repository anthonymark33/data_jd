<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd Technotes</title>

<link rel="stylesheet" href="jda.css" type="text/css">

</head>
<body>
<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;Technotes</span>
<span class=ms>J-integrated<br>columnar<br>analytics</span>
</div>

<div contenteditable="false">

<h2>links</h2>
<P>Folder symbolic links (Windows folder junctions) are used to place db cols on different drives.</p>

<p>Possible benefits:
<ul><li>i/o load balancing across drives</li>
<li>some cols can be placed on ssd drives</li>
<li>total db size irrelevant - only limit is biggest col must fit on a drive</li></ul></p>

See Admin jdlinkmove, jdlinkset, and jdlinktargets for details.

<p>See tutorial link_tut.</p>
<h2>performance measurement</h2>
<p>Folder pm has scripts for performance measurement.</p>

<h2>col - locale/mapping</h2>
<p>Column data is stored in a file in the database folder structure.
The file is mapped to a J noun for processing.
A J locale has col metadata and the noun that is mapped to the file.</p>

<p>When a db is opened (any op does an open if not already open)
locales are created to match the db structure.
In particular, it creates a locale with metadata and file mapping for each column.</p>

<h2>internals - locales/mappings</h2>
<p>Sometimes it can be useful to dig into the internals.</p>
<code>   jdadminx'test'
   jd'gen test f 3'
   c=. jdglc_jd_'f int' NB. get locale for column int in table f 
   ;CLASS__c
jdcolumn
   NAME__c
int
   dat__c
100 101 102
   t=. jdglt_jd_'f'    NB. get locale for table f
   ;CLASS__t
jdtable
   Tlen__t
3
   mappings_jmf_
...</code>

<h2>update</h2>
<p>Update is done as delete/insert. Changed rows are marked deleted and
new rows of merged new/old data are appended.</p>

<p>An option to do update in-place might be nice.
Consider a large table with 100 cols where a typical update changes the value in 1 col
of 1 row. Update as delete/insert reads 100 different areas of disk to get the old values,
then writes 100 different new areas of disk. An update in-place would be much faster.</p>

<h2>crash recovery</h2>

<p>Bugs and hardware failures can damage a db and there is more that could be done to make Jd more resilent.</p>

<p><tt>jd'validate'</tt> should be extended to report more problems and should have an option to correct problems.<p>

<p>It might be worthwhile to have a db jdstate flag maintained for open/changed/closed.
Complicated by various levels of disk buffering and can only work if there is a reliable flush mechanism.
Would allow detecting the db did not shutdown cleanly and flag that <tt>jd'validate'</tt> was required.

<p>A change log of delete/update/insert operations could be used to rebuild a damaged table from a known Tlen.
Simply drop Tlen back to the value at the start of the change log, run change log ops, and rebuild dynamic cols.

<h2>backup</h2>

<p>Complete backup or restore is just a copy of the db file folder.
Host shell scripts can provide full backup/restore.
With large databases and suitable hardware it might be worthwhile to use multiple tasks and use compression.</p>

</p>CSV dump/restore with rebuild of dynamics also provides complete backup.</p>

<p>With update as delete/insert an incremental backup tool could be easily built that dumps just jdactive and
and the rows after Tlen in the full backup.</p>

</div></body></html>
