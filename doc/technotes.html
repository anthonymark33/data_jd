<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd Technotes</title>

<link rel="stylesheet" href="jda.css" type="text/css">

</head>
<body>
<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;Technotes</span>
<span class=ms>J-integrated<br>columnar<br>analytics</span>
</div>

<div contenteditable="false">

<h2>file handles</h2>
<p>Jd requires lots of file handles. Each column uses a handle
and each reference can use 5 handles.
A database with many columns (over multiple tables) can require many 100s of handles.</p>

<p>Linux/Mac typically have a default limit on handles of 256 or 1024.
There is no reason to not raise the limit significantly for Jd.
A limit of 256 will cause<code> jdtests_jd_'' </code>to fail.
You probably want to raise the limit to at least 4096 and depending on
your databases and use patterns you may need more.</p>

<p>Windows does not have a limit on file handles.</p>

<p>Jd fails badly if it runs out of handles. It is unable to access a required file
and this can be reported as a failure to map a file or as a limit error on file operations.
You can check the number of handles used by mapped files with <code>#mappings_jmf_</code>
and compare this with your limit on file handles.</p>

<p>You can't increase the limit from within J and need to increase it in the shell task
(e.g. <code>...$ ulimit -n 4096 </code>) before launching J.
You can check your file handle limit with<code> 2!:0'ulimit -n' </code>in J.</p>

<h2>links</h2>
<P>Folder symbolic links (Windows folder junctions) are used to place db cols on different drives.</p>

<p>Possible benefits:
<ul><li>i/o load balancing across drives</li>
<li>some cols can be placed on ssd drives</li>
<li>total db size irrelevant - only limit is biggest col must fit on a drive</li></ul></p>

See Admin jdlinkmove, jdlinkset, and jdlinktargets for details.

<p>See tutorial link_tut.</p>
<h2>performance measurement</h2>
<p>Folder pm has scripts for performance measurement.</p>

<h2>developer</h2>
<p>Jd is distributed with JAL (Package Manager) and the Jd library is at ~addons/data/jd and is
accessed with the following equivalent lines:<br>
<code>   load'data/jd'</code><br>
<code>   load'~addons/data/jd/jd.ijs'</code><br>

<p>A developer works with a local repo. Use the development library with something like:<br>
<code>   load'~/dev/addons/data/jd/jd.ijs'</code><br>



<p>Loading jd.ijs sets JDP_z_ as the path to the Jd library and this is used for all library references.</p>

<p>An automated process copies the developer repo to the addon svn repo to build a new Jd release.</p>

<h2>col - locale/mapping</h2>
<p>Column data is stored in a file in the database folder structure.
The file is mapped to a J noun for processing.
A J locale has col metadata and the noun that is mapped to the file.</p>

<p>When a db is opened (any op does an open if not already open)
locales are created to match the db structure.
In particular, it creates a locale with metadata and file mapping for each column.</p>

<h2>internals - locales/mappings</h2>
<p>Sometimes it can be useful to dig into the internals.</p>
<code>   jdadminx'test'
   jd'gen test f 3'
   c=. jdglc_jd_'f int' NB. get locale for column int in table f 
   ;CLASS__c
jdcolumn
   NAME__c
int
   dat__c
100 101 102
   t=. jdglt_jd_'f'    NB. get locale for table f
   ;CLASS__t
jdtable
   Tlen__t
3
   mappings_jmf_
...</code>

<h2>update</h2>
<p>Update is done as delete/insert. Changed rows are marked deleted and
new rows of merged new/old data are appended.</p>

<p>An option to do update in-place might be nice.
Consider a large table with 100 cols where a typical update changes the value in 1 col
of 1 row. Update as delete/insert reads 100 different areas of disk to get the old values,
then writes 100 different new areas of disk. An update in-place would be much faster.</p>

<h2>crash recovery</h2>

<p>Bugs and hardware failures can damage a db and there is more that could be done to make Jd more resilent.</p>

<p><tt>jd'validate'</tt> should be extended to report more problems and should have an option to correct problems.<p>

<p>It might be worthwhile to have a db jdstate flag maintained for open/changed/closed.
Complicated by various levels of disk buffering and can only work if there is a reliable flush mechanism.
Would allow detecting the db did not shutdown cleanly and flag that <tt>jd'validate'</tt> was required.

<p>A change log of delete/update/insert operations could be used to rebuild a damaged table from a known Tlen.
Simply drop Tlen back to the value at the start of the change log, run change log ops, and rebuild dynamic cols.

<h2>backup</h2>

<p>Complete backup or restore is just a copy of the db file folder.
Host shell scripts can provide full backup/restore.
With large databases and suitable hardware it might be worthwhile to use multiple tasks and use compression.</p>

</p>CSV dump/restore with rebuild of dynamics also provides complete backup.</p>

<p>With update as delete/insert an incremental backup tool could be easily built that dumps just jdactive and
and the rows after Tlen in the full backup.</p>

</div></body></html>
