<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd Technical</title>

<link rel="stylesheet" href="jda.css" type="text/css">

</head>
<body>
<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;Technical</span>
<span class=ms><a href="http://www.jsoftware.com" target="_blank">www.jsoftware.com</a><br>J database - J language<br>columnar analytics</span>
</div>


<div contenteditable="false">


<a href="#backup">backup</a> -
<a href="#centos">centos</a> -
<a href="#crash">crash recovery</a> - 
<a href="#developer">developer</a> - 
<a href="#handles">file handles</a> - 
<a href="#links">links</a> - 
<a href="#locales">locales</a> - 
<a href="#performance">performance measurement</a> - 
<a href="#ref">ref</a> - 
<a href="#reference">reference</a> - 
<a href="#update">update</a> 

<h2><a name="backup">backup</h2>

<p>Complete backup or restore is just a copy of the db file folder.
Host shell scripts can provide full backup/restore.
With large databases and suitable hardware it might be worthwhile to use multiple tasks and use compression.</p>

</p>CSV dump/restore with rebuild of dynamics also provides complete backup.</p>

<p>With update as delete/insert an incremental backup tool could be easily built that dumps just jdactive and
and the rows after Tlen in the full backup.</p>

<h2><a name="centos">centos</h2>

Jd linux shared library built on recent distributions fails on some releases of CentOS
(and presumably similar Red Hat releases). Loading Jd will get:<code>

'Jd shared library failure' assert ...
   cderx''
'... GLIBC_2.14 not found ...'

</code>
Workaround is to use libjd_centos.so that was built on CentOS.
To use it do something like the following:
<code>

...$ cd ~/addons/data/jd/cd
...$ mv libjd.so libjd_not_centos.so
...$ mv libjd_centos.so libjd.so
...$ chmod +x libjd.so
</code>





<h2><a name="crash">crash recovery</h2>

<p>Bugs and hardware failures can damage a db and there is more that could be done to make Jd more resilient.</p>

<p><tt>jd'validate'</tt> should be extended to report more problems and should have an option to correct problems.<p>

<p>It might be worthwhile to have a db jdstate flag maintained for open/changed/closed.
Complicated by various levels of disk buffering and can only work if there is a reliable flush mechanism.
Would allow detecting the db did not shutdown cleanly and flag that <tt>jd'validate'</tt> was required.

<p>A change log of delete/update/insert operations could be used to rebuild a damaged table from a known Tlen.
Simply drop Tlen back to the value at the start of the change log, run change log ops, and rebuild dynamic cols.

<h2><a name="developer">developer</h2>
<p>Jd is distributed with JAL (Package Manager) and the Jd library is at ~addons/data/jd and is
accessed with the following equivalent lines:<br>
<code>   load'data/jd'</code><br>
<code>   load'~addons/data/jd/jd.ijs'</code><br>

<p>A developer works with a local repo. Use the development library with something like:<br>
<code>   load'~/dev/addons/data/jd/jd.ijs'</code><br>

<p>Loading jd.ijs sets JDP_z_ as the path to the Jd library and this is used for all library references.</p>

<p>An automated process copies the developer repo to the addon svn repo to build a new Jd release.</p>


<h2><a name="handles">file handles</h2>
<p>Jd requires lots of file handles. Using thousands of columns requires thousands of handles.</p>

<p>Jd fails badly if it runs out of handles. Unable to access a file, an error is signaled,
perhaps in the middle of an operation that will leave the database damaged.</p>

<p>Windows user does not have a limit on file handles.</p>

<p>Linux/Mac user by default has low limit on handles and
this must be increased for serious use of Jd. 
On modern systems there is no reason to not raise the limit to 200000.</p>

<p>To increase file handle limit for Linux Jd user fred:
<code>

...$ ulimit -n # show current file handle limit
run superuser text editor and open /etc/security/limits.conf
add following 2 lines at the end

fred soft nofile 200000
fred hard nofile 200000

save the file, restart the system, and verify new ulimit
</code></p>

<p>To increase file handle limit for Mac Jd user the steps are similar, but of course
different, and the details are left to the reader.</p>

<h2><a name="links">links</h2>

<P>Folder symbolic links (Windows folder junctions) are used to place db cols on different drives.</p>

<p>Possible benefits:
<ul><li>i/o load balancing across drives</li>
<li>some cols can be placed on ssd drives</li>
<li>total db size irrelevant - only limit is biggest col must fit on a drive</li></ul></p>

See Admin jdlinkmove, jdlinkset, and jdlinktargets for details.

<p>See tutorial link_tut.</p>

<h2><a name="locales">locales</h2>
<p>Parts of a database (tables, cols, data) correspond directly with the file structure.
That is, a table is a folder in the database, each col is
a folder in its table folder, and data is a file in its col folder.<p>

<p>When a database is opened, J locales are created that correspond to the database structure.
Each table has a locale with metadata and each col has a locale with metadata and mapped file(s)
with the data.<p>

<p>Sometimes it can be useful to dig into the internals.</p>
<code>   jdadminx'test'
   jd'gen test f 3'
   jd'reads from f'
   t=. jdgl_jd_'f'   NB. get locale for table f
   NAME__t           NB. table name
   NAMES__t          NB. col names in table
   c=. jdgl_jd_'f x' NB. get locale for col x in table f
   typ__c            NB. column type
   PATH__c           NB. path to col dat file
   dat__c            NB. mapped file data
</code>

<h2><a name="performance">performance measurement</h2>

See pmhelp_jd_ for info.

<p>Folder pm has scripts for performance measurement.</p>

<h2><a name="ref">ref</h2>
.../db/tab/refcol/jdstate has dirty flag and starts as 1
set 0 whenever ref col is recalculated
set 1 when delete/update/insert done to either table.
jdstate written whenever dirty flag changes
db can be closed with dirty 1


<p>Command 'ref f a g b' creates f-datl dynamic col and provides only
left1 join. A ref is on 1 or more data cols.
It is simpler than a reference, requires much less space,
and in some cases is faster.</p>

<p>A 1gb int data col requires only the single 1gb int datl dynamic col.</p>

<p>Delete/update/insert sets the datl col dirty flag to indicate datl
is not valid. The datl col is recalculated (leftcols i. rightcols) as
required before use.</p>

<p>File .../db/tab/refcol/jdstate has the dirty flag. It starts as 1.
Set 0 whenever datl is refreshed. Set 0 when a delete/update/insert
is done to either table. File jdstate is written whenever dirty changes.
The database can be closed with dirty 1 and that will be the state when the database is opened.</p>

<p>The time to create a reference between tables each with 100e6 rows
on an int col on platform with 6gb ram is 4 seconds.</p>

<p>If possible ref should be used and reference avoided.
Especially for large tables.</p>


<h2><a name="reference">reference</h2>

<p> Command 'reference f a g b' creates f-datl, f-datr, f-hash_a,
f-link_a, g-hash_b,
and g-link_b dynamic cols and allows outer/inner/left/right/left1 joins.
Hash cols are double size. A reference is on 1 or more data cols.</p>

<p> A reference on an int col with tables of the same size has an
overhead of 8 times. A 1gb int col reference has 8gb of dynamic cols.
With 2 cols in the reference there would be 16gb of dynamic cols.</p>

<p> Data col changes (inserts/deletes/updates) affect dynamic cols.
This is complicated and expensive. Dynamic col changes are done for
every operation.
Timings have not been done, but dynamic updates likely make changes
significantly slower, especially for large tables.</p>

<p> The time to create a reference between tables each with 100e6 rows
on an int col with 24gb ram is 30 minutes.
It would take forever with 6gb ram because of thrash.</p>

<p>A reference provides all join types and is fast for a static database.
But it has a very high overhead in space and can be very slow for changes.
A database that was otherwise reasonable on a machine with limited ram (6gb) would not be able to build the reference.</p>

<p><red>Delete/update is prevented on a table in a reference as currently the dynamic cols would not reflect the change.<red></p>

<h2><a name="update">update</h2>
<p>Update is done as delete/insert. Changed rows are marked deleted and
new rows of merged new/old data are appended.</p>

<p>An option to do update in-place might be nice.
Consider a large table with 100 cols where a typical update changes the value in 1 col
of 1 row. Update as delete/insert reads 100 different areas of disk to get the old values,
then writes 100 different new areas of disk. An update in-place would be much faster.</p>


</div></body></html>
