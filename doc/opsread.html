<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>Jd Ops read</title>
<link rel="stylesheet" href="jda.css" type="text/css">

<body>
<div class=masthead>
<img src="./jblue.png" width="50px" height="50px"/>
<span class=md>d</span>
<span class=mt>&nbsp;Ops read</span>
<span class=ms><a href="http://www.jsoftware.com" target="_blank">www.jsoftware.com</a><br>J database - J language<br>columnar analytics</span>
</div>

<div contenteditable="false">
<code>
<a href="#read">read</a> <a href="#reads">reads</a> <a href="#readtc">readtc</a>

<a href="#parse">parsing</a> read ops can be complicated
<hr><a name="read"><h2>read</h2></a>
same as reads with /lr option

<hr><a name="reads"><h2>reads</h2></a>
reads [<a href="#options">OPTIONS</a>] [<a href="#select">SELECT</a>] from <a href="#from">FROM</a> [where <a href="#where">WHERE</a>] [order by <a href="#oby">ORDER BY</a>]

returns select col(s) from table(s) with rows that satisfy where
alias:col
alias:table
aggregation [by key1[,key2]]

For ideas on working with reads results, see essay <a href="http://code.jsoftware.com/wiki/Essays/Inverted_Table" target="_blank">Inverted Table</a>.

NB. example reads
jdadminx'example'[olddan=:jdaccess''
jd'gen ref2 a 3 1 b 2'
jd'reads from a'
jd'reads from b'
jd'reads akey,adata from a'
jd'reads from a,a.b'
jd'reads from a where akey&lt;3'
jd'reads from a,a.b where akey&lt;3 and b.bref=0'
jd'reads asdf:b.bb12 from a,a.b where akey&lt;3 and b.bref=0'
jd'reads sum adata from a where akey&gt;0'
jd'reads sum adata by aref from a'
jdaccess olddan

<hr><a name="readtc"><h2>readtc</h2></a>
readtc ... jdtc sentence

sames as reads except jdtc clause

J sentence is run first to create temp cols

tutorial tempcol

<hr><a name="parse""><h2>parsing</h2></a>
Parsing read ops can be complicated. There are known issues that
can cause problems. Keep things simple to avoid unknown problems

clauses where,order by,jdset,jdtc are strippd from the end and must
appear, if present, in that order

use blanks before and after keywords

anything can appear in WHERE between "s
 this is handled and will not cause parse errors

anything can appear in col/table alias
 / at start of SELECT will be treated as option
 keywords (e.g, order by) in alias can cause problems
   
col alias can include blanks, RESERVEDCHARS, and RESERVEDWORDS 
and this is useful as they are result col labels

table alias can include blanks, RESERVEDCHARS, and RESERVEDWORDS
but this is not useful and can cause parse problems

some problems are avoided as:
 RESERVEDWORDS_jd_ are not allowed as col/table names
 RESERVEDCHARS_jd_ are not allowed in col/table names

<hr><a name="options""><h2>OPTIONS</h2></a>
/lr - labeled rows instead of labeled cols 
/e  - edate... cols as epochdt rather than iso 8601

<hr><a name="select""><h2>SELECT</h2></a>
read SELECT from ...

Select determines which columns are in the result

 cola
 alias:cola
 cola,colb
 *
 tabf.cola,tabg.colc
 *.*
  sum cola
 sum cola,avg colb
 sum cola by key1
 sum cola by key1,key2

   jd'info agg' NB. database agg functions (includes custom functions)
   
<h3>select clause details</h3>
Select: Column(, Column)*
      | AggCol(, AggCol)*
      | AggCol(, AggCol)* by Column(, Column)*
Column: [alias:] [Tab.]Col
AggCol: [alias:] agg [Tab.]Col
Tab: table  | "*"
Col: column | "*"

Tab is name of a table in the from clause
(alias, name, or the column used to reference it)
root table is used if there is no TAB

Col is name of a column in the corresponding table

alias is a name

agg is an aggregation function

if not an aggregation then * can be used for Tab and Col
if Tab is *, then that column will be shown for all tables
if Col is *, then all columns from the table will be used
Tab expanded first so  *.* gives all columns from all tables
If no Columns are given, then *.* is used, or * if only one table

result name for a col is its alias, or how it was identified

by keyword groups rows by the key columns that follow it
each aggregator is called on the rows of its column in each group

result col label does not include agg, so an alias is desirable

<hr><a name="from"><h2>FROM</h2></a>
read ... from FROM ...

tutorial from

from Table (, Table)*
Table:     Root | Child
Root:      [alias:] table
Child:     [alias:] [JoinWord] Parent(Reference)(Reference)*
Parent:    alias | table
Reference: table | reference column
JoinWord:  default | inner | left | right | outer
Join:        .     |   -   |  &lt;   |   &gt;   |   =

The default join is also called left1.

Only one of the Tables can be the Root.
The name of a table is either its alias or the last element of its
description (i.e. the table for the Root, and the last Reference for
Children). A table can only have one name: if an alias is given, the
other name will not be used.
Each Parent must be included as the name of some Table in the list.
No order is enforced on the Tables, in particular, a Child does
not have to follow its Parent.

example:
from A.B, A, C:B&lt;jdreference_a_C_a, inner C.D, B&gt;E-F

The join used to join a Reference to the table before it is
either the one corresponding to the Join symbol used, or,
if Join is . and JoinWord is given, that given by JoinWord.

By default joins are done in an optimal (not guaranteed)
order based on a sampling that picks representative rows
and tests how restrictive the queries are. The algorithm
should be fairly robust.

exact keyword indicates to use the order as given.
   jd'read from exact f,f-g,g-h where h.a&lt;100'

<h3>from clause - join</h3>
joins: outer = inner -  left &gt;  right &lt;  left1 .

outer join A,A=B
 all possible rows
 A rows duplicated for each match in B
 B rows duplicated for each match in A
 A or B FILLS provided where no match

inner join A,A-B:
 same as outer except rows with FILLS are excluded
 
left join A,A&gt;B
 same as outer except B rows that did not match are excluded
 
right join A,A&lt;B
 same as outer except A rows that did not match are excluded

left1 join A,A.B
 each A row with 1 matching B row or FILLS
 if multiple matching B rows, 1 random one of them is used
 not a normal join, but is fast
 same as inner join if 1 and only 1 B row matches 


<hr><a name="where"><h2>WHERE</h2></a>
read ... from ... where WHERE

 a="abc"
 b&lt;23
 b in (23,24,25)
 b lt 23 && a eq "abc"
 a like "ab*" 
 f.a=23 && g.b="def"
 a range (1000,2000)
 a=1 and b=2
 a,b = 1,2          - same as above but uses a,b hash if available
 (a=1 and b=2) or (a=3 and b=4)
 a,b in (1,2),(3,4) - same as above but uses a,b hash if available

relationals:
 &gt;= &lt;= &lt;&gt; =  &gt;  &lt;
 ge le ne eq gt lt range
 in notin like unlike sample sample.
 
 sample n returns n random rows
 sample. users ?. instead of ?

 non-symbol must be blank delimited

 byte data must be in "s and has C escapes (\" \t \n \0 \x09 ...)
 numeric data must not be in "s

 like/unlike regex applies to all types

 relationals have implied parens (which must not be present)
 
 a=c (c not a number and not in "s) is a relation between 2 cols

 t (no col/relational) selects rows from table t not created by join

logicals:
 !   &&  ||
 not and or

 must be blank delimited

 logicals evaluate as J (right to left)
  not a=23 && b=24 || b=25  ===  not((a=23)&&((b=24)||(b=25)))

 parens can change the order of evaluation

<h3>where clause details</h3>
W:  ("!" | "not ")* W1
W1: W2 (" " ("and"|"or"|"&&"|"||") " " W)?
W2: "(" W ")"  |  Q
Q:  col relational dat  |  col relational col  |  tab

col is col name as in select and tab is table name

Q expressions are in implicit parens, which must not be present.

dat represents a J noun; typically this must have the same type as the
items of the column, but its type depends on the operation being used.
If dat is a string or byte, it must be quoted; otherwise it
will be interpreted as numeric data, a column name, or an error.

Strings are in "s and C escapes (\", \n, etc.) can be used.

Logicals (! $$ || not and or) are grouped from right to left as in J,
with parentheses allowed for grouping.

The three types of simple query:
- For an operation on a col and data, the data is fixed so
  that it has the appropriate type and shape.
  For most operations, this is the same type and shape as an
  item in the column. For in and notin, its items will have
  that type and shape. For sample and sample., it
  will be converted to a single number. See the section on data
  conversion below. After conversion, the operation will be applied
  to select qualifying rows in the column.
- For an operation on two columns, the operation will be applied to
  pairs of rows from the two columns to select qualifying rows. The
  operations in, notin, like, unlike, sample, and sample. are not
  available on columns.
- The single table query selects rows that are not null.
  Null rows are created by some joins and do not correspond to a
  row in the table. They are indicated with fills.

The relationals:
- (&gt;= &lt;= &gt; &lt; range) are for numeric cols
- range arg is list of numbers, which is split into pairs
  if an odd number, the last range extends to _
  matches are in the range(s) (inclusive)
- in and notin test whether col value is an element of the list
- like and unlike take a regex and test if the col data matches
- sample and sample. require a data argument that is a single number

Data can be converted either to string (or byte) or numbers.
Numbers must include only the characters -_. and digits.
Strings must be quoted to avoid confusion with keywords and col names.

Following escapes are allowed in quoted strings:
\"     double quote
\\     backslash
\a     alert (BEL)
\b     backspace
\e     escape
\f     form feed
\n     new line
\r     carriage return
\t     horizontal tab
\v     vertical tab
\xHH   byte with hexadecimal value HH

Following escapes may be supported but their use is discouraged:
\NNN   byte with octal value NNN (1 to 3 digits)
\xHH   byte with hexadecimal value HH (1 to 2 digits)
\uHHHH Unicode  (ISO/IEC  10646)  character with hex value HHHH (4 digits)
\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)

Data is adjusted to the shape of the column. A list of data can
be provided by separating items with spaces (this works with numbers or
strings). If the data is smaller than the column shape, it will be
filled with the fill element corresponding to the column type. If it is
larger, an error is signalled.

For in and notin, data is given in a comma-separated list,
optionally enclosed by parens.

In Q expression of the form "col = dat" or "col in dat",
col can be a comma-separated list of cols. In this case each item
in dat is a comma-separated list with the same length as the number of
cols. If the relational is "in", each item in dat must be parenthesized.
The col values are compared with the items in dat. If there is a hash
columns it will be used for the query.

<hr><a name="oby"><h2>ORDER BY</h2></a>
one or more cols separated by commas that are used to sort the final result

</code></div></div></body></html>
